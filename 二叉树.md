# 结构
```
typedef struct TNode *Position;
typedef Position BitTree;
struct TNode
{
    ElementType Data;
    BitTree Left;
    BitTree Right;
}
```

# 遍历
## 先序遍历
先输出根节点，在输出左儿子，右儿子
### 递归遍历程序
```
void PreOrderTraversal( BitTree BT )
{
    if (BT)
    {
        cout << BT->Data;
        PreOrderTraversal( BT->Left);
        PreOrderTraversal( BT->Right);
    }
}
```

### 非递归遍历程序
1. 运用堆栈存放根节点，再次弹出时获得右儿子的指针，然后往右边遍历
2. 往下遍历时：根节点读数，压栈，左儿子读数，压栈，以此类推
3. 往下遍历到底后，往回走，出栈，得到右儿子指针。
4. 重复2,3至全部遍历完成
```
void PreOrderTraversal(BitTree BT)
{
    BitTree T = BT;
    Stack S = CreatStack();
    while (T||!IsEmpty(S))
    {
        while(T)
        {
            Push(S,T);
            cout << T->Data;
            T = T->Left;
        }
        if(!IsEmpty(S))
        {
            T = Pop(S);
            T = T->Right;
        }
    }
}
```

## 中序遍历
先输出左儿子，在输出根节点，右儿子
### 递归遍历程序
```
void InOrderTraversal( BitTree BT )
{
    if (BT)
    {
        PostOrderTraversal( BT->Left);
        cout << BT->Data;
        PostOrderTraversal( BT->Right);
    }
}
```

### 非递归遍历程序
```
void InOrderTraversal(BitTree BT)
{
    BitTree T = BT;
    Stack S = CreatStack();
    while (T||!IsEmpty(S))
    {
        while(T)
        {
            Push(S,T);
            T = T->Left;
        }
        if(!IsEmpty(S))
        {
            T = Pop(S);
            cout << T->Data;
            T = T->Right;
        }
    }
}
```

## 后序遍历
先输出左儿子，在输出右儿子，根节点
### 递归遍历程序
```
void PostOrderTraversal( BitTree BT )
{
    if (BT)
    {
        PostOrderTraversal( BT->Left);
        PostOrderTraversal( BT->Right);
        cout << BT->Data;
    }
}
```

## 层序遍历
运用队列一层一层地遍历二叉树。
根节点入队，出队，访问，左右儿子依次入队，以此类推
```
void LevelOrderTraversal(BitTree BT)
{
    Queue Q;
    BitTree T;
    if (!BT)
    {
        return;
    }
    Q = CreatQueue ();
    AddQ(Q,BT);
    while (!IsEmpty(S))
    {
        T = DeleteQ(Q);
    cout << T->Data;
    if (T->Left)
    {
        AddQ(Q,T->Left);
    }
    if (T->Right)
    {
        AddQ(Q,T->Right);
    }
    }
}
```

# 建树
```
void CreateTree(BitTree &T)//建树
{
	int item;
	cin >> item;
	if (item == -9)
	{
		T = nullptr;
	}
	else
	{
		T = new TNode;//new新认识
		T->Data = item;
		CreateTree(T->Left);
		CreateTree(T->Right);
	}
}
```

# 二叉搜索树
1. 非空左子树的所有键值小于其根结点的键值
2. 非空右子树的所有键值大于其根结点的键值
3. 左、右子树都是二叉搜索树

## 建立
通过循环与插入函数，不断地把数据插进二叉树，最后成为二叉搜索树

## 查找
```
Position IterFind(ElementType X, BitTree T)
{
    while(T)
    {
        if (X > T->Data)
        {
            T = T->Right;
        }
        else if  (X<T->Data)
        {
            T = T->Left;
        }
        else return T;
    }
}

Position FindMin（BitTree T)
{
    if (!T) return NULL:
    else if (!T->) return T;
    else return FindMin(T->Left);
}

Position FindMax（BitTree T)
{
    if (T)
    {
        while (T->Right)
        {
             T == T->Right;
        }
        return T;
    }
    
}
```

## 插入
```
BinTree Insert( BinTree T, ElementType X )
{
    if( !T )
    { // 若原树为空，生成并返回一个结点的二叉搜索树 
        T = new BitTree; 
        T->Data = X;
        T->Left = T->Right = NULL;
    }
    else 
    { // 开始找要插入元素的位置 
        if( X < T->Data )
            T->Left = Insert( T->Left, X );   //递归插入左子树
        else  if( X > T->Data )
            T->Right = Insert( T->Right, X ); //递归插入右子树
         //else X已经存在，什么都不做 
    }
    return T;
}
 ```
## 删除
```
BinTree Delete( BinTree T, ElementType X ) 
{ 
    Position Tmp; 
    if( !T ) 
       cout << "要删除的元素未找到" << endl;
    else {
        if( X < T->Data ) 
            T->Left = Delete( T->Left, X );   // 从左子树递归删除 
        else if( X > T->Data ) 
            T->Right = Delete( T->Right, X ); // 从右子树递归删除 
        else { //T就是要删除的结点 
            // 如果被删除结点有左右两个子结点 
            if( T->Left && T->Right ) {
                // 从右子树中找最小的元素填充删除结点 
                Tmp = FindMin( T->Right );
                T->Data = Tmp->Data;
                // 从右子树中删除最小元素 
                T->Right = Delete( T->Right, T->Data );
            }
            else { // 被删除结点有一个或无子结点 
                Tmp = T; 
                if( !T->Left )       //只有右孩子或无子结点 
                    T = T->Right; 
                else                   //只有左孩子 
                    T = T->Left;
                free( Tmp );
            }
        }
    }
    return T;
}
``` 

## 修改
先把要修改的结点删除，再添加新数据

## 销毁
```
void DestroyTree(BitTree T)
{
    if (!T == NULL)
    {
        DestroyTree(T->Left);
        DestroyTree(T->Right);
    }
}